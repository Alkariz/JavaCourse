https://github.com/Alkariz/JavaCourse

Смысла в приостановке .join() я не увидел. Да, каждая нить перед стартом ждёт некоторое время. Но коллизии происходят вне зависимости от времени приостановки перед стартом.
Yield - в xmind была ошибка. Тоже смысла в функции не заметил, хуже того, цифры, полученные, в результате использования функции, стали хуже.
Задание приоритетов тоже особо не изменило результат, потому что коллизии всё равно получались у нитей одного приоритета. Проверял на большом количестве thread'ов.

Работаю на другом языке программирования, параллельные вычисления используются регулярно, варианты работы с потоками разные.

Пулы потоков: вот эта "игрушка" весьма интересна! 
- Синхронизованные потоки у меня в работе используются постоянно, например, при вычислении объёмов и(или) площадей. Чаще всего, без особых проблем, связанных с передачей активного статуса другим потокам, поскольку интересует именно финальный результат, без промежуточных значений.
- Структура Future весьма интересна, но в моей работе не пригодится. Проще начать вычислять, выдав прогресс бар, а по окончанию всех вычислений, отобразить результат.
- FixedThreadPool используется! Есть большое количество задач, которые можно решить параллельно. Есть фиксированное количество потоков. Запустили, а там уже в каком-то порядке они будут что-то считать. 
- ReentrantLock: не смог придумать, как использовать такой способ многопоточной работы для своих задач.
- Condition также не смог придумать задачи для использования такого способа.
- Семафоры используются. Сложно, муторно, но используются. 
- ReadWriteLock используются регулярно. Много объектов используют вычисления с применением такой структуры. 
- StampedLock не очень понял, возможно, какие-то хитрые особенности использования, которые надо знать.
- CountDownLatch не понял. 
- CyclocBarrier также используется в работе.
- Phaser понятен, возможно, удобен, но у нас не используется.
- BlinkngPhaser немного непонятен. К тому же сумел вылететь с результатом -MaxInt.
- AtomicInteger вполне понятен, у нас не используется, потому что проще завести массив интов, а потом в цикле сложить результаты.
- BlockingQueue понятна, используется реже других вариантов.
- TransferQueue понятна, но использовать в работе не получится.
- ComplitionService - ага! Вот примерно такая штука у нас постоянно используется! 
- ConcurrentHashMap использовать в работе не получится.
- Fork/Join - понятен, используется.

На работе вообще взаимные блокировки не используются. Есть монитор, который отслеживает такие ситуации, есть критические секции. При вычислении все нити имеют одинаковый приоритет, поэтому не возникает проблем с нежелательной блокировкой. Работа выполняется в том же порядке, при котором попали в критическую секцию.

4.1 синхронизировать доступ к message:
4.1.1 с помощью synchronized не сработало. Возможно, я накосячил при использовании;
4.1.2 с помощью Lock- отработало не во всех случаях
4.2 дождаться завершения нити корректора с помощью join() - отработало в 100% случаев;
4.3 вставить Thread.sleep()- отработало в 100% случаев, правда пришлось менять местами строки;
4.4 поменять между собой строки - вообще не сработало.

Анализ приложения Toll. Если честно, я не вполне уверен, что анализирую правильное приложение, поэтому уточняю - анализировать буду своё приложение, написанное по заданиям курса.
https://github.com/Alkariz/JavaCourse
Tracker-core - модуль, обязательный к переработке на многопоточные вычисления!
1) Сервис GPSService - может собирать точки в во всех потоках, которые сможет получить, записывая их не в List<>, а в BlockingDeque. Обязательно помнить про проблему SimpleDateFormat, который используется в парсере файла, где живут точки.
2) Сервис StoreGPSDataService:
а) может жить в бесконечном цикле с попыткой взять точку из BlockingDeque, живущей в GPSService. 
б) Либо использовать Lock на момент чтения точек из GPSService, чтобы новые не добавлялись и не происходила коллизия.
3) 
а) В принципе, PushMessagesService можно не переводить на многопоточную работу, он по времени будет возвращать точки, причём, можно отправлять не по одной точке, а всем скопом все полученные.
б) Перевести PushMessagesService на многопоточную работу - отправлять все полученные точки по одной в разных потоках. Но тогда придётся менять функцию приёма точек в Server-core

В server-core ничего менять не нужно, он получает точку/точки и записывает их в БД - там всё уже реализовано.
Но! В случае многопоточной отправки точек стоит вставить Lock в функцию записи полученной точки в файл.

В Server-ui менять пока нечего - реальные функции отображения точек реализованы в модуле server-core и не имеют шаблонов вывода.